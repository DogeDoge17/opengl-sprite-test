#ifndef SHADERS_H
#define SHADERS_H

const char* norm_vert_shader =
"#version 330 core\n"
"\n"
"layout(location = 0) in vec3 aPos;\n"
"layout(location = 1) in vec3 aNormal;\n"
"layout(location = 2) in vec2 aTexCoord;\n"
"\n"
"uniform mat4 model;\n"
"uniform mat4 projection;\n"
"\n"
"out vec3 FragPos;\n"
"out vec3 Normal;\n"
"out vec2 v_TexCoord;\n"
"\n"
"void main()\n"
"{\n"
"    FragPos = vec3(model * vec4(aPos, 1.0));\n"
"    Normal = mat3(transpose(inverse(model))) * aNormal;\n"
"    v_TexCoord = aTexCoord;\n"
"    gl_Position = projection * model * vec4(aPos, 1.0);\n"
"}\n";

const char* bicubic_frag_shader =
"#version 330 core\n"
"\n"
"uniform sampler2D u_Texture;\n"
"uniform vec2 u_TextureSize;\n"
"in vec2 v_TexCoord;\n"
"\n"
"out vec4 FragColor;\n"
"\n"
"float cubicWeight(float x) {\n"
"    if (x < 1.0) {\n"
"        return (1.5 * x - 2.5) * x * x + 1.0;\n"
"    } else if (x < 2.0) {\n"
"        return ((-0.5 * x + 2.5) * x - 4.0) * x + 2.0;\n"
"    } else {\n"
"        return 0.0;\n"
"    }\n"
"}\n"
"\n"
"vec4 textureBicubic(sampler2D tex, vec2 texCoord, vec2 texSize) {\n"
"    vec2 texelSize = 1.0 / texSize;\n"
"    vec2 coord = texCoord * texSize - 0.5;\n"
"\n"
"    vec2 f = fract(coord);\n"
"    coord -= f;\n"
"\n"
"    vec4 result = vec4(0.0);\n"
"\n"
"    for (int j = -1; j <= 2; j++) {\n"
"        for (int i = -1; i <= 2; i++) {\n"
"            vec2 offset = vec2(float(i), float(j));\n"
"            vec2 sampleCoord = (coord + offset) * texelSize;\n"
"            vec4 samplez = texture(tex, sampleCoord);\n"
"\n"
"            float wx = cubicWeight(abs(f.x - float(i)));\n"
"            float wy = cubicWeight(abs(f.y - float(j)));\n"
"\n"
"            result += samplez * wx * wy;\n"
"        }\n"
"    }\n"
"\n"
"    return result;\n"
"}\n"
"\n"
"void main() {\n"
"    FragColor = textureBicubic(u_Texture, v_TexCoord, u_TextureSize);\n"
"}\n";

const char *lanczos_frag_shader =
        "#version 330 core\n"
        "\n"
        "uniform sampler2D u_Texture;\n"
        "uniform float u_ScaleFactor;\n"
        "uniform int u_LanczosA;\n"
        "in vec2 v_TexCoord;\n"
        "\n"
        "out vec4 FragColor;\n"
        "\n"
        "const float PI = 3.141592653589793;\n"
        "const float EPSILON = 1e-6;\n"
        "\n"
        "float sinc(float x) {\n"
        "    if (abs(x) < EPSILON) return 1.0;\n"
        "    x *= PI;\n"
        "    return sin(x) / x;\n"
        "}\n"
        "\n"
        "float lanczos(float x, int a) {\n"
        "    if (abs(x) < float(a)) {\n"
        "        return sinc(x) * sinc(x / float(a));\n"
        "    } else {\n"
        "        return 0.0;\n"
        "    }\n"
        "}\n"
        "\n"
        "void main() {\n"
        "    vec2 texSize = textureSize(u_Texture, 0);\n"
        "    vec2 coord = v_TexCoord * texSize;\n"
        "\n"
        "    vec2 base = floor(coord);\n"
        "    vec2 frac = coord - base;\n"
        "\n"
        "    vec4 color = vec4(0.0);\n"
        "    float totalWeight = 0.0;\n"
        "\n"
        "    for (int j = -u_LanczosA + 1; j <= u_LanczosA; ++j) {\n"
        "        for (int i = -u_LanczosA + 1; i <= u_LanczosA; ++i) {\n"
        "            vec2 samplePos = base + vec2(i, j);\n"
        "            vec2 offset = coord - samplePos;\n"
        "\n"
        "            float weight = lanczos(offset.x, u_LanczosA) * lanczos(offset.y, u_LanczosA);\n"
        "            color += texture(u_Texture, samplePos / texSize) * weight;\n"
        "            totalWeight += weight;\n"
        "        }\n"
        "    }\n"
        "\n"
        "    if (totalWeight > EPSILON) {\n"
        "        FragColor = color / totalWeight;\n"
        "    } else {\n"
        "        FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n"
        "    }\n"
        "}\n";

const char *sharp_lanczos_frag_shader =
        "#version 330 core\n"
        "\n"
        "uniform sampler2D u_Texture;\n"
        "uniform float u_ScaleFactor;\n"
        "uniform int u_LanczosA;\n"
        "in vec2 v_TexCoord;\n"
        "\n"
        "out vec4 FragColor;\n"
        "\n"
        "const float PI = 3.141592653589793;\n"
        "const float EPSILON = 1e-6;\n"
        "\n"
        "float sinc(float x) {\n"
        "    if (abs(x) < EPSILON) return 1.0;\n"
        "    x *= PI;\n"
        "    return sin(x) / x;\n"
        "}\n"
        "\n"
        "float lanczos(float x, int a) {\n"
        "    float ax = abs(x);\n"
        "    if (ax < float(a)) {\n"
        "        return sinc(x) * sinc(x / float(a));\n"
        "    } else {\n"
        "        return 0.0;\n"
        "    }\n"
        "}\n"
        "\n"
        "void main() {\n"
        "    vec2 texSize = textureSize(u_Texture, 0);\n"
        "    vec2 coord = v_TexCoord * texSize;\n"
        "\n"
        "    vec2 base = floor(coord);\n"
        "    vec2 frac = coord - base;\n"
        "\n"
        "    vec4 color = vec4(0.0);\n"
        "    float totalWeight = 0.0;\n"
        "\n"
        "    // Lanczos filtering\n"
        "    for (int j = -u_LanczosA + 1; j <= u_LanczosA; ++j) {\n"
        "        for (int i = -u_LanczosA + 1; i <= u_LanczosA; ++i) {\n"
        "            vec2 samplePos = base + vec2(i, j);\n"
        "            vec2 offset = coord - samplePos;\n"
        "\n"
        "            float weight = lanczos(offset.x, u_LanczosA) * lanczos(offset.y, u_LanczosA);\n"
        "            color += texture(u_Texture, samplePos / texSize) * weight;\n"
        "            totalWeight += weight;\n"
        "        }\n"
        "    }\n"
        "\n"
        "    // Normalize the result\n"
        "    vec4 lanczosResult;\n"
        "    if (totalWeight > EPSILON) {\n"
        "        lanczosResult = color / totalWeight;\n"
        "    } else {\n"
        "        lanczosResult = texture(u_Texture, v_TexCoord);\n"
        "    }\n"
        "    \n"
        "    // Apply sharpening filter\n"
        "    vec4 top = textureOffset(u_Texture, v_TexCoord, ivec2(0, -1));\n"
        "    vec4 bottom = textureOffset(u_Texture, v_TexCoord, ivec2(0, 1));\n"
        "    vec4 left = textureOffset(u_Texture, v_TexCoord, ivec2(-1, 0));\n"
        "    vec4 right = textureOffset(u_Texture, v_TexCoord, ivec2(1, 0));\n"
        "    \n"
        "    // Calculate blur from neighboring pixels\n"
        "    vec4 blur = (top + bottom + left + right) * 0.25;\n"
        "    \n"
        "    // Apply sharpening to the Lanczos result\n"
        "    const float sharpness = 0.3;\n"
        "    FragColor = lanczosResult + (lanczosResult - blur) * sharpness;\n"
        "}\n";


const char* mitchell_frag_shader =
"#version 330 core\n"
"\n"
"uniform sampler2D u_Texture;\n"
"uniform vec2 u_TextureSize;\n"
"in vec2 v_TexCoord;\n"
"\n"
"out vec4 FragColor;\n"
"\n"
"float mitchell(float x) {\n"
"    float B = 1.0/3.0;\n"
"    float C = 1.0/3.0;\n"
"    \n"
"    float ax = abs(x);\n"
"    if (ax < 1.0) {\n"
"        return ((12.0 - 9.0*B - 6.0*C)*ax*ax*ax + (-18.0 + 12.0*B + 6.0*C)*ax*ax + (6.0 - 2.0*B))/6.0;\n"
"    } else if (ax < 2.0) {\n"
"        return ((-B - 6.0*C)*ax*ax*ax + (6.0*B + 30.0*C)*ax*ax + (-12.0*B - 48.0*C)*ax + (8.0*B + 24.0*C))/6.0;\n"
"    } else {\n"
"        return 0.0;\n"
"    }\n"
"}\n"
"\n"
"vec4 textureMitchell(sampler2D tex, vec2 texCoord, vec2 texSize) {\n"
"    vec2 texelSize = 1.0 / texSize;\n"
"    vec2 coord = texCoord * texSize - 0.5;\n"
"    vec2 f = fract(coord);\n"
"    coord -= f;\n"
"\n"
"    vec4 result = vec4(0.0);\n"
"    float totalWeight = 0.0;\n"
"\n"
"    for (int j = -1; j <= 2; j++) {\n"
"        for (int i = -1; i <= 2; i++) {\n"
"            vec2 offset = vec2(float(i), float(j));\n"
"            vec2 sampleCoord = (coord + offset) * texelSize;\n"
"            vec4 sample = texture(tex, sampleCoord);\n"
"\n"
"            float wx = mitchell(f.x - float(i));\n"
"            float wy = mitchell(f.y - float(j));\n"
"            float weight = wx * wy;\n"
"\n"
"            result += sample * weight;\n"
"            totalWeight += weight;\n"
"        }\n"
"    }\n"
"\n"
"    return result / totalWeight;\n"
"}\n"
"\n"
"void main() {\n"
"    FragColor = textureMitchell(u_Texture, v_TexCoord, u_TextureSize);\n"
"}\n";
const char* catmull_rom_frag_shader =
"#version 330 core\n"
"\n"
"uniform sampler2D u_Texture;\n"
"uniform vec2 u_TextureSize;\n"
"in vec2 v_TexCoord;\n"
"\n"
"out vec4 FragColor;\n"
"\n"
"float catmullRom(float x) {\n"
"    float ax = abs(x);\n"
"    if (ax <= 1.0) {\n"
"        return 1.5*ax*ax*ax - 2.5*ax*ax + 1.0;\n"
"    } else if (ax <= 2.0) {\n"
"        return -0.5*ax*ax*ax + 2.5*ax*ax - 4.0*ax + 2.0;\n"
"    } else {\n"
"        return 0.0;\n"
"    }\n"
"}\n"
"\n"
"void main() {\n"
"    vec2 texelSize = 1.0 / u_TextureSize;\n"
"    vec2 coord = v_TexCoord * u_TextureSize - 0.5;\n"
"    vec2 f = fract(coord);\n"
"    coord -= f;\n"
"\n"
"    vec4 result = vec4(0.0);\n"
"\n"
"    for (int j = -1; j <= 2; j++) {\n"
"        for (int i = -1; i <= 2; i++) {\n"
"            vec2 offset = vec2(float(i), float(j));\n"
"            vec2 sampleCoord = (coord + offset) * texelSize;\n"
"            vec4 sample = texture(u_Texture, sampleCoord);\n"
"\n"
"            float wx = catmullRom(f.x - float(i));\n"
"            float wy = catmullRom(f.y - float(j));\n"
"\n"
"            result += sample * wx * wy;\n"
"        }\n"
"    }\n"
"\n"
"    FragColor = result;\n"
"}\n";

const char* fsr_like_frag_shader =
        "#version 330 core\n"
        "\n"
        "uniform sampler2D u_Texture;\n"
        "uniform vec2 u_TextureSize;\n"
        "in vec2 v_TexCoord;\n"
        "\n"
        "out vec4 FragColor;\n"
        "\n"
        "void main() {\n"
        "    vec2 texelSize = 1.0 / u_TextureSize;\n"
        "    \n"
        "    vec4 center = texture(u_Texture, v_TexCoord);\n"
        "    \n"
        "    // Use textureOffset for better performance\n"
        "    vec4 top = textureOffset(u_Texture, v_TexCoord, ivec2(0, -1));\n"
        "    vec4 bottom = textureOffset(u_Texture, v_TexCoord, ivec2(0, 1));\n"
        "    vec4 left = textureOffset(u_Texture, v_TexCoord, ivec2(-1, 0));\n"
        "    vec4 right = textureOffset(u_Texture, v_TexCoord, ivec2(1, 0));\n"
        "    \n"
        "    // Pre-computed constants\n"
        "    const float inv4 = 0.25;\n"
        "    const float sharpness = 0.3;\n"
        "    \n"
        "    // Single mad operation\n"
        "    vec4 blur = (top + bottom + left + right) * inv4;\n"
        "    FragColor = center + (center - blur) * sharpness;\n"
        "}\n";


const char* adaptive_sharpen_frag_shader =
"#version 330 core\n"
"\n"
"uniform sampler2D u_Texture;\n"
"uniform vec2 u_TextureSize;\n"
"uniform float u_SharpnessAmount;\n"
"in vec2 v_TexCoord;\n"
"\n"
"out vec4 FragColor;\n"
"\n"
"float rgb2luma(vec3 rgb) {\n"
"    return dot(rgb, vec3(0.299, 0.587, 0.114));\n"
"}\n"
"\n"
"void main() {\n"
"    vec2 texelSize = 1.0 / u_TextureSize;\n"
"    \n"
"    vec4 center = texture(u_Texture, v_TexCoord);\n"
"    \n"
"    // Sample surrounding pixels\n"
"    vec4 top = texture(u_Texture, v_TexCoord + vec2(0.0, -texelSize.y));\n"
"    vec4 bottom = texture(u_Texture, v_TexCoord + vec2(0.0, texelSize.y));\n"
"    vec4 left = texture(u_Texture, v_TexCoord + vec2(-texelSize.x, 0.0));\n"
"    vec4 right = texture(u_Texture, v_TexCoord + vec2(texelSize.x, 0.0));\n"
"    \n"
"    // Calculate local contrast\n"
"    float centerLuma = rgb2luma(center.rgb);\n"
"    float maxLuma = max(max(rgb2luma(top.rgb), rgb2luma(bottom.rgb)), \n"
"                       max(rgb2luma(left.rgb), rgb2luma(right.rgb)));\n"
"    float minLuma = min(min(rgb2luma(top.rgb), rgb2luma(bottom.rgb)), \n"
"                       min(rgb2luma(left.rgb), rgb2luma(right.rgb)));\n"
"    \n"
"    float contrast = maxLuma - minLuma;\n"
"    \n"
"    // Adaptive sharpening based on local contrast\n"
"    vec4 blur = (top + bottom + left + right) * 0.25;\n"
"    float adaptiveSharpness = u_SharpnessAmount * min(contrast * 2.0, 1.0);\n"
"    \n"
"    FragColor = center + (center - blur) * adaptiveSharpness;\n"
"}\n";

const char* simple_frag_shader =
"#version 330 core\n"
"\n"
"uniform sampler2D u_Texture;\n"
"in vec2 v_TexCoord;\n"
"\n"
"out vec4 FragColor;\n"
"\n"
"void main() {\n"
"    FragColor = texture(u_Texture, v_TexCoord);\n"
"}\n";

#endif // SHADERS_H